<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Seminar Cloud App – v5.7 (Final)</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Font: Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: 'Inter', sans-serif; }
    /* Use style.display instead of hidden class now */
    /* @keyframes spin { to { transform: rotate(360deg); } } */
    /* .loader { border: 4px solid rgba(255,255,255,.2); border-top-color:#3b82f6; border-radius:50%; width:3rem; height:3rem; animation: spin 1s linear infinite; } */
    /* Simplified loader */
     @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loader {
        border: 4px solid #f3f3f3; /* Light grey */
        border-top: 4px solid #3b82f6; /* Blue */
        border-radius: 50%;
        width: 48px; /* 3rem */
        height: 48px; /* 3rem */
        animation: spin 1s linear infinite;
        margin: auto; /* Center loader if needed */
    }
    video { background: #0f172a; }
    /* Network banner state colors */
    #network-status.online   { background-color:#166534; color:#bbf7d0; }
    #network-status.limited  { background-color:#92400e; color:#fde68a; }
    #network-status.offline  { background-color:#7f1d1d; color:#fecaca; }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 md:p-8">

  <!-- Error Display Area -->
  <div id="error-display" class="fixed top-0 left-0 right-0 bg-red-800 text-white p-4 z-[100] border-b-2 border-red-600 font-mono text-sm whitespace-pre-wrap" style="display: none;">
    <strong>JavaScript Error:</strong><br>
    <span id="error-message"></span>
  </div>

  <div class="max-w-3xl mx-auto">
    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 bg-gray-900 flex flex-col items-center justify-center z-50" style="display: flex;">
      <div class="loader"></div>
      <p class="text-gray-400 mt-4">Initializing App...</p>
    </div>

    <!-- Setup Screen (shown first if no Firebase config) -->
    <div id="setup-screen" class="bg-gray-800 p-6 rounded-2xl shadow-2xl space-y-4" style="display: none;">
      <h1 class="text-2xl font-bold">Project Setup</h1>
      <p class="text-gray-300 text-sm">Paste your <span class="font-semibold">Firebase Web App config JSON</span> and choose an App ID namespace. You can also continue in offline mode for testing.</p>
      <div>
        <label class="text-sm text-gray-300">App ID (namespace)</label>
        <input id="setup-appid" class="mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3" placeholder="seminar-cloud-dev" />
      </div>
      <div>
        <label class="text-sm text-gray-300">Firebase Config JSON</label>
        <textarea id="setup-config" rows="8" class="mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg p-3 font-mono text-sm" placeholder='{"apiKey":"...","authDomain":"...","projectId":"...","storageBucket":"...","appId":"..."}'></textarea>
      </div>
      <div class="flex gap-3">
        <button id="setup-save" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-lg">Save & Continue</button>
        <button id="setup-offline" class="bg-yellow-600 hover:bg-yellow-500 text-black font-semibold px-4 py-2 rounded-lg">Continue in Offline Mode</button>
      </div>
      <p class="text-yellow-300 text-xs">⚠️ Offline mode stores data locally and will try to sync later when you add Firebase config.</p>
      <div id="setup-tests" class="mt-4 text-sm"></div>
    </div>

    <!-- Auth Screen (shown when Firebase configured but user not linked) -->
    <div id="auth-screen" class="text-center bg-gray-800 p-8 rounded-2xl shadow-2xl" style="display: none;">
      <h1 class="text-3xl font-bold mb-2">Seminar Cloud Record</h1>
      <p class="text-gray-400 mb-4">You are signed in anonymously. Link to Google to sync recordings.</p>
      <button id="sign-in-link-btn" class="w-full max-w-xs mx-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200 flex items-center justify-center">
        <svg class="w-5 h-5 mr-3" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"/><path fill="#FF3D00" d="M6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"/><path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.202 0-9.619-3.317-11.283-7.946l-6.522 5.025C9.505 39.556 16.227 44 24 44z"/><path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C42.012 36.49 44 30.803 44 24c0-1.341-.138-2.65-.389-3.917z"/></svg>
        Link to Google Account
      </button>
      <p class="text-xs text-gray-500 mt-3">Or continue anonymously — data will sync when you link later.</p>
    </div>

    <!-- Main App -->
    <div id="main-app" style="display: none;">
      <header class="flex justify-between items-center mb-3">
        <h1 class="text-3xl font-bold">My Recordings</h1>
        <div class="flex items-center gap-3">
          <span class="text-xs text-gray-300">UID: <span id="user-id-display">—</span></span>
          <button id="sign-out-btn" class="text-sm text-blue-400 hover:text-blue-300">Sign Out</button>
        </div>
      </header>

      <!-- Smart Network Status Bar -->
      <div id="network-status" class="w-full text-center text-sm py-2 rounded-md mb-4 transition-all duration-300" style="display: none;">
        <div><span id="network-status-text">Checking connection...</span></div>
        <div id="last-sync-time" class="text-xs text-gray-300 mt-1 cursor-pointer hover:underline" style="display: none;">🕒 Last synced: —</div>
      </div>

      <!-- Sync Top Bar: progress + log toggle + summary -->
      <div id="sync-progress" class="bg-blue-900 text-white text-sm p-2 rounded-md shadow-md flex flex-col space-y-1 mb-2" style="display: none;">
        <div class="flex justify-between items-center">
          <div>🔄 Uploading <span id="sync-count">0</span> / <span id="sync-total">0</span> (<span id="sync-percent">0%</span>)</div>
          <div class="flex items-center space-x-2">
            <button id="sync-cancel" class="bg-blue-700 hover:bg-blue-800 px-2 py-1 rounded text-xs">Cancel</button>
            <button id="sync-toggle-log" class="text-xs text-blue-300 hover:text-blue-200">View Log ▼</button>
          </div>
        </div>
        <div id="sync-log" class="bg-gray-800 rounded p-2 text-xs max-h-32 overflow-y-auto border border-gray-700" style="display: none;"></div>
        <div class="flex justify-end mt-1 space-x-3">
          <button id="copy-log-btn" class="text-blue-300 hover:text-blue-200 text-xs">📋 Copy Log</button>
          <button id="export-log-btn" class="text-blue-300 hover:text-blue-200 text-xs">📄 Export Log</button>
        </div>
      </div>
      <div id="sync-summary" class="bg-green-800 text-green-100 text-sm p-2 rounded-md shadow-md mt-2 mb-2 flex justify-between items-center" style="display: none;">
        <span id="sync-summary-text">✅ Sync Complete</span>
        <button id="view-log-btn" class="bg-green-700 hover:bg-green-600 text-white text-xs px-2 py-1 rounded">📄 View Log ▼</button>
      </div>

      <!-- Manage Class Period Titles -->
      <div id="class-management" class="bg-gray-800 p-6 rounded-2xl shadow-lg mb-6">
        <h2 class="text-2xl font-bold mb-6">Manage Class Periods</h2>
        <form id="class-management-form" class="space-y-4"></form>
        <button id="save-classes-btn" class="w-full mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg">Save Class Titles</button>
      </div>

      <!-- Recording Panel -->
      <div class="bg-gray-800 p-6 rounded-2xl shadow-lg mb-6">
        <h2 class="text-2xl font-bold mb-4">Record (Video + Audio)</h2>
        <div class="grid md:grid-cols-3 gap-4 items-start">
          <div class="md:col-span-2">
            <video id="preview" class="w-full rounded-lg shadow aspect-video" playsinline muted autoplay></video>
          </div>
          <div class="space-y-3">
            <div class="text-sm text-gray-400">Status: <span id="rec-status" class="text-gray-300">Idle</span></div>
            <div class="text-sm text-gray-400">Timer: <span id="rec-timer" class="text-gray-300">00:00</span></div>
            <button id="toggle-camera-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-lg disabled:opacity-50">🔄 Switch Camera</button>
            <button id="start-rec-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-lg">Start Recording</button>
            <button id="pause-rec-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-3 rounded-lg" disabled>Pause</button>
            <button id="stop-rec-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-3 rounded-lg" disabled>Stop & Tag</button>
            <p id="rec-hint" class="text-xs text-gray-500"></p>
            <div class="text-xs text-gray-400">If <code>video/webm</code> isn’t supported, try Chrome/Edge desktop.</div>
          </div>
        </div>
      </div>

      <!-- Tag + Save Metadata -->
      <div class="bg-gray-800 p-6 rounded-2xl shadow-lg mb-6">
        <h2 class="text-2xl font-bold mb-6">Add Recording Metadata</h2>
        <form id="tag-form" class="space-y-4">
          <div>
            <label for="school" class="block text-sm font-medium text-gray-300">School Name</label>
            <input type="text" id="school" required class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3" />
          </div>
          <div>
            <label for="teacher" class="block text-sm font-medium text-gray-300">Teacher</label>
            <input type="text" id="teacher" required class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3" />
          </div>
          <div>
            <label for="class-period" class="block text-sm font-medium text-gray-300">Class Period</label>
            <select id="class-period" required class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3">
            <option value="">Select a period...</option>
            </select>
          </div>
          <div>
            <label for="student" class="block text-sm font-medium text-gray-300">Student</label>
            <select id="student" required class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-lg py-2 px-3" disabled>
              <option value="">Select a class period first...</option>
            </select>
          </div>
          <div class="grid grid-cols-2 gap-3 text-sm text-gray-400">
            <div>Duration: <span id="final-duration">00:00</span></div>
            <div>Size: <span id="final-size">0 B</span></div>
          </div>
          <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">Save & Upload</button>
        </form>
      </div>

      <!-- Saved Recordings -->
      <div>
        <h2 class="text-2xl font-bold mb-4">Saved Recordings</h2>
        <div id="recording-list" class="space-y-3">
          <p id="no-recordings" class="text-gray-400 text-center py-4" style="display: block;">No recordings found.</p>
        </div>
      </div>

      <!-- Pending Uploads (auto-expands when there are cached items) -->
      <div id="pending-uploads" class="mt-8 bg-yellow-900/30 p-6 rounded-2xl shadow-inner border border-yellow-700" style="display: none;">
        <h2 class="text-xl font-bold mb-4 text-yellow-400">📦 Pending Uploads (Offline)</h2>
        <div id="pending-progress" class="mb-4" style="display: none;">
          <div class="flex justify-between text-xs text-yellow-300 mb-1">
            <span id="pending-progress-text">Uploading 0 of 0...</span>
            <span id="pending-progress-percent">0%</span>
          </div>
          <div class="w-full bg-yellow-950 rounded-full h-2 overflow-hidden">
            <div id="pending-progress-bar" class="bg-yellow-400 h-2 w-0 transition-all duration-300"></div>
          </div>
        </div>
        <p id="no-pending" class="text-gray-400 text-center py-4" style="display: block;">No pending uploads. All synced ✅</p>
        <div id="pending-list" class="space-y-3"></div>
        <button id="retry-all-btn" class="mt-4 bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-2 px-4 rounded-lg text-sm" style="display: none;">🔁 Retry All Now</button>
      </div>
    </div>
  </div>
  <!-- Sync History Modal -->
  <div id="sync-history-modal" class="fixed inset-0 bg-black/60 flex items-center justify-center z-50" style="display: none;">
    <div class="bg-gray-800 w-80 rounded-xl shadow-2xl p-4">
      <h3 class="text-lg font-bold text-white mb-3">Recent Sync History</h3>
      <div id="sync-history-list" class="max-h-60 overflow-y-auto text-sm text-gray-300 space-y-2"></div>
      <button id="close-history" class="w-full mt-4 bg-gray-700 hover:bg-gray-600 text-white py-2 rounded-lg text-sm">Close</button>
    </div>
  </div>

  <!-- Firebase SDK + App Logic -->
  <script type="module">
    // ---------- Global Error Catcher ----------
    let appMode = ''; // Add this line
const mainAppScreen = document.getElementById('main-app'); // 
    const errorDisplay = document.getElementById('error-display');
    const errorMessageEl = document.getElementById('error-message');
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global Error:", message, source, lineno, colno, error);
      if (errorMessageEl) {
        errorMessageEl.textContent = `Message: ${message}\nSource: ${source}\nLine: ${lineno}, Col: ${colno}\nError: ${error?.stack || error}`;
      }
      if (errorDisplay) {
        errorDisplay.style.display = 'block'; // Use direct style
      }
      const loading = document.getElementById('loading-screen');
      if(loading) loading.style.display = 'flex'; // Keep loading visible
      return true; // Prevent default browser error handling
    };
    window.addEventListener('unhandledrejection', function(event) {
        console.error('Unhandled Promise Rejection:', event.reason);
         if (errorMessageEl) {
             errorMessageEl.textContent = `Unhandled Promise Rejection:\n${event.reason?.stack || event.reason}`;
         }
         if (errorDisplay) {
            errorDisplay.style.display = 'block'; // Use direct style
         }
         const loading = document.getElementById('loading-screen');
         if(loading) loading.style.display = 'flex'; // Keep loading visible
    });
    console.log('Error handlers attached.');
    // ----------------------------------------

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
      getAuth, onAuthStateChanged, GoogleAuthProvider,
      signInWithPopup, signOut, signInAnonymously, linkWithPopup,
      signInWithCustomToken
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getFirestore, collection, addDoc, query, onSnapshot,
      serverTimestamp, setLogLevel, doc, getDoc, setDoc
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import {
      getStorage, ref as sRef, uploadBytesResumable, getDownloadURL
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

    // ---------- Simple IndexedDB helpers ----------
    function openIndexedDB(name, version=1){ /* ... code ... */ return new Promise((resolve, reject)=>{ const req = indexedDB.open(name, version); req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('pendingUploads')){ db.createObjectStore('pendingUploads', { keyPath: 'id' }); } }; req.onsuccess = ()=> resolve(req.result); req.onerror = ()=> reject(req.error); }); }
    async function idbAdd(store, value){ const db = await openIndexedDB('seminar-cloud',1); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).add(value); tx.oncomplete=()=>res(); tx.onerror=(e)=>rej(tx.error || e); }); }
    async function idbPut(store, value){ const db = await openIndexedDB('seminar-cloud',1); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(value); tx.oncomplete=()=>res(); tx.onerror=(e)=>rej(tx.error || e); }); }
    async function idbGetAll(store){ const db = await openIndexedDB('seminar-cloud',1); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const req=tx.objectStore(store).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=(e)=>rej(req.error || e); }); }
    async function idbDelete(store, key){ const db = await openIndexedDB('seminar-cloud',1); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key); tx.oncomplete=()=>res(); tx.onerror=(e)=>rej(tx.error || e); }); }

    // ---------- DOM refs ----------
    let loadingScreen, setupScreen, setupAppId, setupConfig, setupSave, setupOffline, setupTests, authScreen, signInLinkBtn, mainApp, signOutBtn, userIdDisplay, networkStatus, networkText, lastSyncEl, classManagementForm, saveClassesBtn, recordingList, noRecordingsMsg, classPeriodSelect, studentSelect, preview, startBtn, stopBtn, pauseBtn, toggleCameraBtn, recStatus, recTimer, finalDuration, finalSize, recHint, syncProgress, syncCount, syncTotal, syncPercent, syncCancel, syncToggleLog, syncLog, copyLogBtn, exportLogBtn, syncSummary, syncSummaryText, viewLogBtn, pendingSection, pendingProgress, pendingProgressText, pendingProgressPercent, pendingProgressBar, pendingList, pendingEmpty, retryAllBtn, historyModal, historyList, closeHistoryBtn;

    function initializeDomRefs() {
        loadingScreen = document.getElementById('loading-screen');
        setupScreen = document.getElementById('setup-screen');
        setupAppId = document.getElementById('setup-appid');
        setupConfig = document.getElementById('setup-config');
        setupSave = document.getElementById('setup-save');
        setupOffline = document.getElementById('setup-offline');
        setupTests = document.getElementById('setup-tests');
        authScreen = document.getElementById('auth-screen');
        signInLinkBtn = document.getElementById('sign-in-link-btn');
        mainApp = document.getElementById('main-app');
        signOutBtn = document.getElementById('sign-out-btn');
        userIdDisplay = document.getElementById('user-id-display');
        networkStatus = document.getElementById('network-status');
        networkText = document.getElementById('network-status-text');
        lastSyncEl = document.getElementById('last-sync-time');
        classManagementForm = document.getElementById('class-management-form');
        saveClassesBtn = document.getElementById('save-classes-btn');
        recordingList = document.getElementById('recording-list');
        noRecordingsMsg = document.getElementById('no-recordings');
        classPeriodSelect = document.getElementById('class-period');
        studentSelect = document.getElementById('student');
        preview = document.getElementById('preview');
        startBtn = document.getElementById('start-rec-btn');
        stopBtn = document.getElementById('stop-rec-btn');
        pauseBtn = document.getElementById('pause-rec-btn');
        toggleCameraBtn = document.getElementById('toggle-camera-btn');
        recStatus = document.getElementById('rec-status');
        recTimer = document.getElementById('rec-timer');
        finalDuration = document.getElementById('final-duration');
        finalSize = document.getElementById('final-size');
        recHint = document.getElementById('rec-hint');
        syncProgress = document.getElementById('sync-progress');
        syncCount = document.getElementById('sync-count');
        syncTotal = document.getElementById('sync-total');
        syncPercent = document.getElementById('sync-percent');
        syncCancel = document.getElementById('sync-cancel');
        syncToggleLog = document.getElementById('sync-toggle-log');
        syncLog = document.getElementById('sync-log');
        copyLogBtn = document.getElementById('copy-log-btn');
        exportLogBtn = document.getElementById('export-log-btn');
        syncSummary = document.getElementById('sync-summary');
        syncSummaryText = document.getElementById('sync-summary-text');
        viewLogBtn = document.getElementById('view-log-btn');
        pendingSection = document.getElementById('pending-uploads');
        pendingProgress = document.getElementById('pending-progress');
        pendingProgressText = document.getElementById('pending-progress-text');
        pendingProgressPercent = document.getElementById('pending-progress-percent');
        pendingProgressBar = document.getElementById('pending-progress-bar');
        pendingList = document.getElementById('pending-list');
        pendingEmpty = document.getElementById('no-pending');
        retryAllBtn = document.getElementById('retry-all-btn');
        historyModal = document.getElementById('sync-history-modal');
        historyList = document.getElementById('sync-history-list');
        closeHistoryBtn = document.getElementById('close-history');
        console.log("DOM refs initialized.");
    }

    // ---------- State ----------
    let app, auth, db, storage;
    let currentUserId = null; window.currentUserId = null;
    let recordingsListener = null; let classData = {};
    let mediaStream = null, mediaRecorder = null, chunks = [];
    let secondsElapsed = 0, timerInterval = null, currentBlob = null;
    let currentFacingMode = 'environment';
    let activeUploadTask = null;
    let session = { total:0, uploaded:0, retried:0, failed:0, start:0 };

    // ---------- Visibility Functions (Using style.display) ----------
    function show(el){ /* ... same as before ... */ if (el) { const displayType = el.tagName === 'DIV' && (el.classList.contains('flex') || el.classList.contains('grid')) ? el.classList.contains('flex') ? 'flex' : 'grid' : 'block'; el.style.display = displayType; console.log(`Forced display='${displayType}' for element:`, el.id || el.tagName); } else { console.warn('Attempted to show a null element'); } }
    function hide(el){ /* ... same as before ... */ if (el) { el.style.display = 'none'; console.log(`Forced display='none' for element:`, el.id || el.tagName); } else { console.warn('Attempted to hide a null element'); } }
    function showScreen(id){ /* ... same as before ... */ console.log(`Attempting to show screen: ${id}`); if (!loadingScreen) initializeDomRefs(); console.log(`Loading screen display=${loadingScreen?.style.display}`); console.log(`Setup screen display=${setupScreen?.style.display}`); console.log(`Auth screen display=${authScreen?.style.display}`); console.log(`Main app display=${mainApp?.style.display}`); hide(loadingScreen); hide(setupScreen); hide(authScreen); hide(mainApp); console.log(`--- After hiding all ---`); console.log(`Loading screen display=${loadingScreen?.style.display}`); console.log(`Setup screen display=${setupScreen?.style.display}`); console.log(`Auth screen display=${authScreen?.style.display}`); console.log(`Main app display=${mainApp?.style.display}`); const screen = document.getElementById(id); if (screen) { console.log(`Found element for screen: ${id}`); if (id === 'loading-screen') { screen.style.display = 'flex'; console.log(`Forced display='flex' for element: loading-screen`); } else { show(screen); } console.log(`Target screen (${id}) display=${screen.style.display}`); } else { console.error(`Screen element NOT found: ${id}`); } console.log(`--- showScreen('${id}') finished ---`); }

    // ---------- Offline helpers ----------
    function offlineSet(key, value){ /* ... same as before ... */ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){ console.warn('Failed to write to localStorage', e); } }
    function offlineGet(key, fallback){ /* ... same as before ... */ try{ const raw=localStorage.getItem(key); return raw? JSON.parse(raw) : fallback; }catch(e){ return fallback; } }

    // ---------- Tests (basic) ----------
    function addTest(msg, pass, note=''){ /* ... same as before ... */ if(!setupTests) return; const line=document.createElement('div'); line.className = pass? 'text-green-400' : 'text-red-400'; line.textContent = `${pass?'PASS':'FAIL'} • ${msg}${note? ' — '+note:''}`; setupTests.appendChild(line); }
    function validateConfig(cfg){ /* ... same as before ... */ const need=['apiKey','projectId','appId']; const missing = need.filter(k=>!cfg||!cfg[k]); return { ok: missing.length===0, missing }; }

    // ---------- Network banner ----------
    function setNetworkStatus(mode, message){ /* ... same as before ... */ if(!networkStatus || !networkText) return; networkStatus.classList.remove('online','limited','offline'); networkStatus.classList.add(mode); networkText.textContent = message; show(networkStatus); }
    function updateLastSyncTime(){ /* ... same as before ... */ if(!lastSyncEl) return; const now=new Date(); const formatted= now.toLocaleString(undefined,{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'}); lastSyncEl.textContent = `🕒 Last synced: ${formatted}`; show(lastSyncEl); offlineSet('lastSync', now.toISOString()); }
    function restoreLastSync(){ /* ... same as before ... */ if(!lastSyncEl) return; const stored=offlineGet('lastSync',null); if(stored){ const d=new Date(stored); const formatted= d.toLocaleString(undefined,{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'}); lastSyncEl.textContent = `🕒 Last synced: ${formatted}`; show(lastSyncEl); } }

    // ---------- Sync log helpers ----------
    function logLine(msg,type='info'){ /* ... same as before ... */ if (!syncLog) return; const el=document.createElement('div'); el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; if(type==='success') el.classList.add('text-green-400'); if(type==='error') el.classList.add('text-red-400'); if(type==='warn') el.classList.add('text-yellow-300'); syncLog.appendChild(el); syncLog.scrollTop = syncLog.scrollHeight; }
    function logHeader(){ /* ... same as before ... */ const firebaseConfig = offlineGet('firebaseConfig',null) || (typeof __firebase_config!=='undefined' && __firebase_config ? JSON.parse(__firebase_config): null); const appId = offlineGet('appId','default-app-id') || (typeof __app_id!=='undefined' && __app_id ? __app_id : 'default-app-id'); const mode = !navigator.onLine? 'Offline' : (auth?.currentUser?.isAnonymous? 'Anonymous' : 'Google Linked'); return [ '=== Seminar Cloud App Sync Log ===', 'Version: v5.7', `App Mode: ${mode}`, `User ID: ${currentUserId||'None'}`, `App ID: ${appId}`, `Firebase Project: ${firebaseConfig?.projectId||'N/A'}`, `Timestamp: ${new Date().toLocaleString()}`, '---------------------------------' ].join('\n'); }
    function logSummary(){ /* ... same as before ... */ const dur=Math.round((Date.now()-session.start)/1000); const m=String(Math.floor(dur/60)).padStart(2,'0'); const s=String(dur%60).padStart(2,'0'); return [ '---------------------------------', 'Session Summary:', `Synced ${session.total} recordings`, `• ${session.uploaded} uploaded to Cloud`, `• ${session.retried} retried successfully`, `• ${session.failed} cached offline`, `Duration: ${m}:${s}`, '---------------------------------' ].join('\n'); }

    // ---------- Toast helper ----------
    function toast(msg,type='info'){ /* ... same as before ... */ document.querySelectorAll('.toast-message').forEach(t => t.remove()); const t=document.createElement('div'); t.className='toast-message fixed bottom-4 right-4 bg-gray-800 border-2 border-gray-700 text-gray-100 px-4 py-3 rounded-lg shadow-lg text-sm z-50 transition-all duration-300 transform translate-y-2 opacity-0'; if(type==='success') t.classList.add('border-green-600'); if(type==='error') t.classList.add('border-red-600'); if(type==='warn') t.classList.add('border-yellow-600'); t.textContent=msg; document.body.appendChild(t); setTimeout(() => { t.classList.remove('translate-y-2', 'opacity-0'); }, 10); setTimeout(()=> { t.classList.add('translate-y-2', 'opacity-0'); setTimeout(() => t.remove(), 300); }, 3500); }

    // ---------- Firebase boot ----------
    function readBootConfig(){ /* ... same as before ... */ const storedCfg = offlineGet('firebaseConfig', null); const storedAppId = offlineGet('appId', null); if(storedCfg && storedAppId){ console.log('Reading config from localStorage'); return { config: storedCfg, appId: storedAppId, from:'localStorage' }; } if(typeof __firebase_config !== 'undefined' && __firebase_config){ console.log('Reading config from global __firebase_config'); try{ const parsed = JSON.parse(__firebase_config); const aid = (typeof __app_id !== 'undefined' && __app_id) ? __app_id : 'default-app-id'; return { config: parsed, appId: aid, from:'globals' }; } catch(e) { console.error('Failed to parse __firebase_config JSON', e); return { config:null, appId:'default-app-id', from:'globals(parse-failed)' }; } } console.log('No config found in localStorage or globals.'); return { config: null, appId: 'default-app-id', from:'none' }; }
    function renderSetupTests(source, cfg){ /* ... same as before ... */ if (!setupTests) return; setupTests.innerHTML=''; addTest(`Config source = ${source}`, !!cfg); const val=validateConfig(cfg||{}); addTest('Firebase config minimal keys (apiKey, projectId, appId)', val.ok, val.ok?'':`Missing: ${val.missing.join(', ')}`); addTest('authDomain present (recommended)', !!cfg?.authDomain, !cfg?.authDomain?'Sign-in may fail':''); addTest('storageBucket present (required for uploads)', !!cfg?.storageBucket, !cfg?.storageBucket?'Uploads disabled':''); }

    // *** THIS IS THE CORRECTED boot() FUNCTION ***
    async function boot(){
      console.log("boot() started");
      try{
        // Initialize DOM refs *after* DOM is ready, called from DOMContentLoaded listener now
        // initializeDomRefs(); // MOVED

        const bootCfg = readBootConfig();
        // Safely assign appId, defaulting if bootCfg is somehow malformed
        window.APP_ID = bootCfg?.appId || 'default-app-id';
        console.log(`Using App ID: ${window.APP_ID}`);

        // *** THIS IS THE CORRECTED CHECK ***
        // Check if config exists AND is valid *before* trying to use its properties
        if(!bootCfg.config || !validateConfig(bootCfg.config).ok){
          console.log('Invalid or missing config, showing setup screen.');
          // Ensure DOM refs are ready before rendering UI updates
          // Use typeof check for safety as initializeDomRefs might not be defined yet
          if (!setupTests && typeof initializeDomRefs === 'function') initializeDomRefs();
          renderSetupTests(bootCfg.from, bootCfg.config); // Pass potentially null config safely
          showScreen('setup-screen'); // Show setup screen
          hide(loadingScreen); // Explicitly hide loading if showing setup
          console.log("boot() finished - showing setup."); // Log exit path
          return; // Stop execution, wait for user input
        }

        // --- Config is valid, proceed with Firebase init ---
        // Ensure projectId exists before logging it
        const projectId = bootCfg.config.projectId || 'N/A';
        console.log('Valid config found. Initializing Firebase with project:', projectId);
        app = initializeApp(bootCfg.config);
        auth = getAuth(app);
        db = getFirestore(app);
        storage = getStorage(app);
        setLogLevel('Debug');
        console.log("Firebase initialized");

        onAuthStateChanged(auth, async (user)=>{
          console.log('onAuthStateChanged fired. User:', user ? user.uid : 'null');
          // Ensure DOM refs are ready before UI updates in async callback
          if (!userIdDisplay && typeof initializeDomRefs === 'function') initializeDomRefs(); // Init if needed

          if(user){
            currentUserId = user.uid; window.currentUserId = user.uid;
            if(userIdDisplay) userIdDisplay.textContent = user.uid.substring(0, 10) + '...' + (user.isAnonymous? ' (anon)':'' );
            showScreen('main-app'); // Show main app
            if(navigator.onLine){ setNetworkStatus('online','🟢 Online — Cloud sync active'); } else { setNetworkStatus('offline','🔴 Offline — Uploads will be saved locally'); }
            restoreLastSync();
            try {
              await postAuthLoad();
              console.log("Post-auth load complete.");
            } catch (err) {
              console.error("Error during post-auth load:", err);
              toast(`Failed to load app data: ${err.message}`, 'error');
            }
          } else {
            currentUserId = null; window.currentUserId = null;
            showScreen('auth-screen'); // Show auth screen if no user
          }
        });
        console.log("onAuthStateChanged listener attached");

        // Try to sign in
        try{
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
             console.log('Attempting sign-in with custom token...');
             await signInWithCustomToken(auth, __initial_auth_token);
             console.log('Custom token sign-in successful.');
          } else {
             console.log('No custom token found or empty, attempting anonymous sign-in...');
             await signInAnonymously(auth);
             console.log('Anonymous sign-in successful.');
          }
        } catch(e){
          console.error('Initial sign-in failed:', e);
          // onAuthStateChanged will handle showing auth screen
        }

      }catch(e){
        console.error('Failed to initialize Firebase or critical boot error:', e);
         // Ensure DOM refs are ready before showing error UI
         if (!errorDisplay && typeof initializeDomRefs === 'function') initializeDomRefs(); // Init if needed
        if(errorMessageEl) errorMessageEl.textContent = `Critical boot error: ${e.message}\n${e.stack}`; // Display error + stack
        if(errorDisplay) show(errorDisplay); // Show error bar
        hide(loadingScreen); // Ensure loading is hidden
        renderSetupTests('init-error', null);
        showScreen('setup-screen'); // Fallback to setup screen
      }
      console.log("boot() finished - main path."); // Log normal exit
    }

    // ---------- Post-auth load ----------
    async function postAuthLoad(){ /* ... same as before ... */ if(recordingsListener) { console.log("Detaching old recordings listener."); recordingsListener(); recordingsListener = null; } const appId = window.APP_ID || 'default-app-id'; console.log(`Post-auth load for user: ${currentUserId}, AppID: ${appId}`); if(db && currentUserId){ try { const p = `artifacts/${appId}/users/${currentUserId}/recordings`; console.log('Setting up new recordings listener at:', p); const qy = query(collection(db, p)); recordingsListener = onSnapshot(qy, (snap) => { console.log(`Recordings snapshot received: ${snap.docs.length} docs`); renderRecordings(snap.docs); }, (err) => { console.error('Recordings snapshot error:', err); toast(`Failed to load recordings: ${err.message}`, 'error'); } ); } catch (err) { console.error('Error setting up recordings listener:', err); } } else { console.warn('No DB or UserID, skipping recordings listener setup.'); renderRecordings([]); } await loadClassData(); await updatePendingUI(); if (navigator.onLine) { console.log('Online on load, checking for pending uploads...'); await retryAllPendingUploads(); } }

    // ---------- Render Recordings List ----------
    function renderRecordings(docs){ /* ... same as before ... */ if(!recordingList) return; recordingList.innerHTML = ''; if (!docs || docs.length === 0) { if (noRecordingsMsg) { show(noRecordingsMsg); } return; } if (noRecordingsMsg) hide(noRecordingsMsg); const sorted = docs.sort((a,b)=>{ const ta = a.data().createdAt?.toMillis?.() || 0; const tb = b.data().createdAt?.toMillis?.() || 0; return tb - ta; }); sorted.forEach(docSnap=>{ const data = docSnap.data(); const el = document.createElement('div'); el.className = 'bg-gray-700 p-4 rounded-lg shadow-md transition-all hover:bg-gray-600'; const date = data.createdAt?.toDate?.()?.toLocaleString?.() || (data.createdAt || 'No date'); const studentName = data.student || 'Unknown Student'; const isSynced = !!data.videoUrl; el.innerHTML = ` <div class="flex justify-between items-start mb-2"> <span class="font-semibold text-lg text-white">${studentName}</span> <span class="text-xs font-medium px-2 py-0.5 rounded-full ${isSynced ? 'bg-green-700 text-green-100' : 'bg-blue-700 text-blue-100'}"> ${isSynced ? 'Synced' : 'Processing'} </span> </div> <p class="text-sm text-gray-300">${data.classPeriod || 'N/A'} - ${data.classTitle || 'N/A'}</p> <p class="text-sm text-gray-400">${data.teacher || 'N/A'} • ${data.school || 'N/A'}</p> <div class="flex justify-between items-center mt-3 pt-2 border-t border-gray-600"> <span class="text-xs text-gray-400">Duration: ${data.duration || '00:00'}</span> <span class="text-xs text-gray-400">${date}</span> </div> `; recordingList.appendChild(el); }); }

    // ---------- Class data ----------
   async function loadClassData(){ 
      const defaultData = { 
        'Period 1': { title:'English', students:['Alice Smith','Bob Johnson','Charlie Brown'] },
        'Period 2': { title:'History', students:['David Lee','Eve White','Frank Green'] },
        'Period 3': { title:'Math', students:['Grace Hall','Henry King','Ivy Scott'] },
        'Period 4': { title:'Science', students:['Jack Turner','Kate Baker','Leo Price'] },
        'Period 5': { title:'Elective 1', students:[] },
        'Period 6': { title:'Elective 2', students:[] },
        'Period 7': { title:'Elective 3', students:[] } 
      };
      
      const cacheKey = `classData_${currentUserId || 'offline'}`;
      
      // Try loading from localStorage first
      classData = offlineGet(cacheKey, null); 
      
      if (classData) {
          console.log('Loaded class data from localStorage cache.');
      } else {
          // If not in localStorage, use defaults (we won't check Firestore yet)
          console.log('No local cache found, using default class data.');
          classData = defaultData;
          // Optionally, save the defaults to localStorage now
          offlineSet(cacheKey, classData);
      }

      // Update the UI
      populateClassManagementUI();
      populateClassPeriodsDropdown(); 
    }
    // ---------- Recording Functions ----------
    const fmt=(s)=>String(s).padStart(2,'0');
    function fmtTime(sec){ return `${fmt(Math.floor(sec/60))}:${fmt(sec%60)}`; }
    function bytesToSize(bytes){ if(bytes===0) return '0 B'; const k=1024, sizes=['B','KB','MB','GB']; const i=Math.floor(Math.log(bytes)/Math.log(k)); return parseFloat((bytes/Math.pow(k,i)).toFixed(2))+" "+sizes[i]; }
    function showModal(title, message) { /* ... same as before ... */ const modalId = `modal-${crypto.randomUUID()}`; const modal = document.createElement('div'); modal.id = modalId; modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 transition-opacity duration-300 opacity-0'; modal.innerHTML = ` <div class="bg-gray-800 w-full max-w-sm rounded-xl shadow-2xl p-6 border border-gray-700 transform transition-all duration-300 scale-95 opacity-0"> <h3 class="text-lg font-bold text-white mb-3">${title}</h3> <p class="text-sm text-gray-300 mb-5">${message}</p> <button class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded-lg text-sm font-semibold focus:outline-none focus:ring-2 focus:ring-blue-500">OK</button> </div> `; modal.querySelector('button').onclick = () => { modal.classList.add('opacity-0'); modal.querySelector('div').classList.add('scale-95'); setTimeout(() => modal.remove(), 300); }; document.body.appendChild(modal); setTimeout(() => { modal.classList.remove('opacity-0'); modal.querySelector('div').classList.remove('scale-95', 'opacity-0'); }, 10); }
    async function startRecording(){ /* ... same as before with camera toggle logic ... */ try{ try { const testStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true }); testStream.getTracks().forEach(track => track.stop()); } catch (permErr) { console.error("Permission error:", permErr); if (permErr.name === "NotAllowedError" || permErr.name === "PermissionDeniedError") { showModal('Permission Denied', 'You must allow access to your camera and microphone to start recording.'); } else if (permErr.name === "NotFoundError" || permErr.name === "DevicesNotFoundError") { showModal('No Devices Found', 'No camera or microphone was found. Please connect your devices and try again.'); } else { showModal('Error', `Could not access media devices: ${permErr.name}. Check browser settings.`); } return; } const constraints={ video:{ width:{ideal:1280}, height:{ideal:720}, facingMode: currentFacingMode }, audio:true }; mediaStream=await navigator.mediaDevices.getUserMedia(constraints); if (preview) { preview.srcObject=mediaStream; preview.muted = true; preview.play().catch(e => console.error("Preview play failed:", e)); } else { console.error("Preview element not found"); mediaStream.getTracks().forEach(track => track.stop()); return; } chunks=[]; currentBlob=null; secondsElapsed=0; if(recTimer) recTimer.textContent='00:00'; const opts=['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm']; let mime=''; for(const m of opts){ if(MediaRecorder.isTypeSupported(m)){ mime=m; console.log('Using mimeType:', mime); break; } } if (!mime) { console.warn('No preferred mimeType supported, using default.'); } mediaRecorder=new MediaRecorder(mediaStream, mime? {mimeType:mime}:undefined); mediaRecorder.ondataavailable=(e)=>{ if(e.data&&e.data.size>0) chunks.push(e.data); }; mediaRecorder.onstop=()=>{ if (mediaStream) { mediaStream.getTracks().forEach(t=>t.stop()); } mediaStream = null; if (preview) preview.srcObject = null; console.log('Media stream stopped.'); }; mediaRecorder.onerror = (e) => { console.error('MediaRecorder error:', e.error); showModal('Recording Error', `An error occurred with the recorder: ${e.error.name}. Please try again.`); stopRecording(); }; mediaRecorder.start(1000); if (timerInterval) clearInterval(timerInterval); timerInterval=setInterval(()=>{ secondsElapsed++; if (recTimer) recTimer.textContent=fmtTime(secondsElapsed); },1000); if (recStatus) { recStatus.textContent='Recording'; recStatus.classList.add('text-red-400', 'font-semibold'); } if (startBtn) startBtn.disabled=true; if (pauseBtn) pauseBtn.disabled=false; if (stopBtn) stopBtn.disabled=false; if (toggleCameraBtn) toggleCameraBtn.disabled = true; if (recHint) recHint.textContent='You can switch tabs; recording continues.'; }catch(err){ console.error('Failed to start recording:', err); if (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError') { showModal('Camera Error', `Could not find a ${currentFacingMode} camera. Try switching cameras.`); currentFacingMode = 'user'; } else { showModal('Start Failed', 'Could not start recording: ' + (err.message || err)); } if (mediaStream) { mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; } if (preview) preview.srcObject = null; if (timerInterval) clearInterval(timerInterval); timerInterval = null; if (startBtn) startBtn.disabled = false; if (pauseBtn) { pauseBtn.disabled = true; pauseBtn.textContent = 'Pause'; } if (stopBtn) stopBtn.disabled = true; if (toggleCameraBtn) toggleCameraBtn.disabled = false; if (recStatus) { recStatus.textContent = 'Error'; recStatus.classList.remove('text-red-400', 'text-yellow-400', 'font-semibold'); } } }
    function pauseOrResume(){ /* ... same as before ... */ if(!mediaRecorder) return; if(mediaRecorder.state==='recording'){ mediaRecorder.pause(); if (pauseBtn) pauseBtn.textContent='Resume'; if (recStatus) { recStatus.textContent='Paused'; recStatus.classList.remove('text-red-400'); recStatus.classList.add('text-yellow-400'); } if (timerInterval) clearInterval(timerInterval); timerInterval = null; } else if(mediaRecorder.state==='paused'){ mediaRecorder.resume(); if (pauseBtn) pauseBtn.textContent='Pause'; if (recStatus) { recStatus.textContent='Recording'; recStatus.classList.remove('text-yellow-400'); recStatus.classList.add('text-red-400'); } if (timerInterval) clearInterval(timerInterval); timerInterval=setInterval(()=>{ secondsElapsed++; if(recTimer) recTimer.textContent=fmtTime(secondsElapsed); },1000); } }
    async function stopRecording(){ /* ... same as before with improved stop logic ... */ if(!mediaRecorder) { console.warn('Stop called, but no mediaRecorder instance.'); return; } if (timerInterval) clearInterval(timerInterval); timerInterval=null; if (mediaRecorder.state === 'inactive') { console.warn('Stop called, but recorder already inactive.'); if (mediaStream) { mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; } if (preview) preview.srcObject = null; return; } let stopped = false; const stopPromise = new Promise(resolve => { mediaRecorder.onstop = () => { console.log('MediaRecorder.onstop triggered.'); stopped = true; if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; } if (preview) preview.srcObject = null; resolve(); }; }); console.log('Calling mediaRecorder.stop()... State:', mediaRecorder.state); if (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused') { mediaRecorder.stop(); } else { if (!stopped) { console.warn("Recorder was inactive, manually cleaning up stream."); if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; } if (preview) preview.srcObject = null; stopped = true; } } await stopPromise; if (chunks.length === 0) { console.error('No data chunks recorded.'); showModal('Recording Error', 'No video data was captured. This can happen if the recording is too short. Please try again.'); if(recStatus) recStatus.textContent='Error'; } else { currentBlob = new Blob(chunks,{type: mediaRecorder.mimeType || 'video/webm'}); console.log('Blob created:', bytesToSize(currentBlob.size), currentBlob.type); if(finalDuration) finalDuration.textContent=fmtTime(secondsElapsed); if(finalSize) finalSize.textContent=bytesToSize(currentBlob.size); if(recStatus) recStatus.textContent='Stopped'; } chunks = []; if(recStatus) recStatus.classList.remove('text-red-400', 'text-yellow-400', 'font-semibold'); if (startBtn) startBtn.disabled=false; if (pauseBtn) { pauseBtn.disabled=true; pauseBtn.textContent='Pause'; } if (stopBtn) stopBtn.disabled=true; if (toggleCameraBtn) toggleCameraBtn.disabled = false; mediaRecorder = null; console.log("stopRecording finished."); }

    // ---------- Save / Upload (handleTagFormSubmit defined later) ----------
    async function cacheOffline(blob, meta, id, timestamp){ /* ... same as before ... */ const rec={ id: id || crypto.randomUUID(), fileBlob: blob, metadata: { ...meta, createdAt: timestamp.toISOString() }, retryCount:0, lastAttempt: timestamp.getTime() }; console.log('Caching offline:', rec.id, rec.metadata.student); try { await idbPut('pendingUploads', rec); await updatePendingUI(); toast('Saved offline. Will retry on reconnect.','warn'); } catch (idbErr) { console.error("Failed to cache offline in IndexedDB:", idbErr); toast('Failed to save offline. Storage might be full or restricted.', 'error'); } }

    // ---------- Retry & Pending UI ----------
    async function updatePendingUI(){ /* ... same as before with null checks... */ let pending = []; try { pending = await idbGetAll('pendingUploads'); } catch (err) { console.error('Failed to read pending uploads from IndexedDB:', err); showModal('Storage Error', 'Could not read pending uploads. Please check browser permissions.'); return; } if(!pendingSection || !pendingList || !pendingEmpty || !retryAllBtn) { console.error("Pending UI elements not found."); return; } if(pending.length===0){ hide(pendingSection); hide(retryAllBtn); pendingList.innerHTML=''; show(pendingEmpty); return; } show(pendingSection); if (navigator.onLine && auth?.currentUser) { show(retryAllBtn); } else { hide(retryAllBtn); } hide(pendingEmpty); pendingList.innerHTML=''; pending.sort((a, b) => a.lastAttempt - b.lastAttempt); pending.forEach(rec=>{ const el=document.createElement('div'); el.className='bg-yellow-800/40 border border-yellow-600 p-3 rounded-lg text-sm flex justify-between items-center'; const studentName = rec.metadata?.student || 'Unknown'; const className = rec.metadata?.classTitle || 'N/A'; const dateString = rec.lastAttempt ? new Date(rec.lastAttempt).toLocaleString() : 'N/A'; el.innerHTML = ` <div> <span class="font-semibold text-yellow-200">${studentName}</span> — ${className} <div class="text-yellow-300 text-xs">Retries: ${rec.retryCount || 0} | Failed: ${dateString}</div> </div> <button class="retry-btn bg-yellow-500 hover:bg-yellow-400 text-black text-xs px-2 py-1 rounded disabled:opacity-50" data-id="${rec.id}">Retry</button>`; pendingList.appendChild(el); }); attachRetryButtonListeners(); }
    function attachRetryButtonListeners() { /* ... same as before ... */ document.querySelectorAll('.retry-btn').forEach(btn=> { btn.replaceWith(btn.cloneNode(true)); const newBtn = pendingList.querySelector(`[data-id="${btn.dataset.id}"]`); if (!newBtn) return; if (!navigator.onLine || !auth?.currentUser) { newBtn.disabled = true; } newBtn.addEventListener('click', async (e)=>{ const target = e.target; if (!target || !(target instanceof HTMLButtonElement)) return; target.disabled = true; target.textContent = 'Retrying...'; session = { total:1, uploaded:0, retried:0, failed:0, start:Date.now() }; show(syncProgress); hide(syncSummary); if(syncLog) syncLog.innerHTML = ''; await retrySingleUpload(target.dataset.id); showSummary(session.failed > 0); updatePendingUI(); }); }); }
    async function retrySingleUpload(id){ /* ... same as before with improved error handling and cancel logic ... */ console.log('Attempting to retry upload for:', id); if (!id) { console.error("Retry called with invalid ID."); return false; } let all = []; try { all = await idbGetAll('pendingUploads'); } catch (e) { console.error("Failed to get pending uploads for retry:", e); return false; } const rec = all.find(r=>r.id===id); if(!rec) { console.warn('Could not find record in IDB for retry:', id); await updatePendingUI(); return false; } if (!rec.fileBlob || !rec.metadata) { console.error("Pending record is incomplete:", rec); logLine(`Retry failed: Record ${id} is incomplete. Removing from cache.`, 'error'); await idbDelete('pendingUploads', rec.id); session.failed++; await updatePendingUI(); return false; } const appId = window.APP_ID || 'default-app-id'; const userId = currentUserId; try{ if(!navigator.onLine || !storage || !auth || !userId) { throw new Error('Offline or Firebase services unavailable for retry'); } const safeStudentName = rec.metadata.student ? rec.metadata.student.replace(/\s+/g, '_') : 'unknown_student'; const timestamp = rec.metadata.createdAt ? new Date(rec.metadata.createdAt).toISOString().replace(/[:.]/g,'-') : Date.now().toString(); const fname = `${timestamp}_${safeStudentName}.webm`; const path = rec.metadata.storagePath || `artifacts/${appId}/users/${userId}/media/${fname}`; console.log('Retrying upload to:', path); logLine(`Retrying upload: ${fname}`); const r = sRef(storage,path); activeUploadTask = uploadBytesResumable(r, rec.fileBlob, {contentType: rec.fileBlob.type || 'video/webm'}); let uploadSuccess = false; await new Promise((resolve, reject) => { activeUploadTask.on('state_changed', (snap) => { const pct = Math.round((snap.bytesTransferred / snap.totalBytes) * 100); if (!syncProgress?.style.display || syncProgress.style.display !== 'none' && session.total === 1) { if(syncCount) syncCount.textContent = (pct===100? '1':'0'); if(syncPercent) syncPercent.textContent = `${pct}%`; if ((pct % 25 === 0 || pct === 100) && pct < 101) logLine(`Uploading ${fname}: ${pct}%`); } }, (err) => { if (err.code !== 'storage/canceled') { console.error(`Upload error during retry for ${id}:`, err); reject(err); } else { console.log("Retry cancelled by user."); activeUploadTask = null; resolve(); } }, async () => { console.log("Upload completed for retry:", id); try { const url = await getDownloadURL(activeUploadTask.snapshot.ref); const meta = { ...rec.metadata, videoUrl: url, createdAt: serverTimestamp(), storagePath: path, retriedCount: (rec.retryCount || 0) }; logLine(`Retry upload complete: ${fname}`, 'success'); const colPath=`artifacts/${appId}/users/${userId}/recordings`; await addDoc(collection(db,colPath), meta); await idbDelete('pendingUploads', rec.id); session.uploaded++; if (rec.retryCount > 0) session.retried++; logLine('Firestore save complete for retry.','success'); updateLastSyncTime(); uploadSuccess = true; } catch (dbOrUrlErr) { console.error(`Retry Firestore save or getURL failed for ${id}:`, dbOrUrlErr); logLine(`Retry Firestore save/getURL failed: ${dbOrUrlErr.message}`, 'error'); } finally { activeUploadTask = null; resolve(); } } ); }); if (!uploadSuccess) { throw new Error("Upload failed, was cancelled, or metadata save failed."); } return true; }catch(err){ console.error(`Retry failed for ${id}:`, err); rec.retryCount = (rec.retryCount || 0) + 1; rec.lastAttempt=Date.now(); try { await idbPut('pendingUploads', rec); } catch (idbErr) { console.error("Failed to update retry count in IndexedDB:", idbErr); } session.failed++; logLine(`Retry failed: ${rec.metadata?.student || id} — ${err.message}`,'error'); activeUploadTask = null; return false; } }
    async function retryAllPendingUploads(){ /* ... same as before with Promise.allSettled ... */ let pending = []; try { pending = await idbGetAll('pendingUploads'); } catch (err) { console.error("Failed to get pending items for retry all:", err); return; } if(pending.length===0) { console.log("No pending uploads to retry."); return; } if (!navigator.onLine || !auth?.currentUser) { console.log('Cannot retry all, offline or not authenticated.'); return; } console.log(`Retrying ${pending.length} pending uploads...`); if(pendingProgress) show(pendingProgress); if(pendingProgressBar) { pendingProgressBar.classList.remove('bg-green-400', 'bg-red-500'); pendingProgressBar.classList.add('bg-yellow-400'); pendingProgressBar.style.width = '0%'; } if(pendingProgressText) pendingProgressText.textContent = `Processing 0 of ${pending.length}...`; if(pendingProgressPercent) pendingProgressPercent.textContent = `0%`; session = { total: pending.length, uploaded:0, retried:0, failed:0, start: Date.now() }; let completedCount = 0; show(syncProgress); hide(syncSummary); if(syncLog) syncLog.innerHTML = ''; show(syncLog); if(syncToggleLog) syncToggleLog.textContent='Hide Log ▲'; if(syncTotal) syncTotal.textContent = pending.length; if(syncCount) syncCount.textContent = 0; if(syncPercent) syncPercent.textContent = '0%'; logLine(`Starting batch retry for ${pending.length} items...`); const results = await Promise.allSettled(pending.map(rec => retrySingleUpload(rec.id))); results.forEach(result => { completedCount++; const percent=Math.round(completedCount / pending.length * 100); if(pendingProgressText) pendingProgressText.textContent=`Processed ${completedCount} of ${pending.length}...`; if(pendingProgressPercent) pendingProgressPercent.textContent=`${percent}%`; if(pendingProgressBar) pendingProgressBar.style.width=`${percent}%`; if(syncCount) syncCount.textContent = session.uploaded; if(syncPercent) syncPercent.textContent = `${percent}%`; }); if(pendingProgressBar) { pendingProgressBar.classList.remove('bg-yellow-400'); if(session.failed === 0){ pendingProgressBar.classList.add('bg-green-400'); if(pendingProgressText) pendingProgressText.textContent='✅ All pending items synced.'; } else if(session.uploaded > 0 || session.retried > 0){ pendingProgressBar.classList.add('bg-yellow-400'); if(pendingProgressText) pendingProgressText.textContent=`⚠️ ${session.uploaded + session.retried} synced, ${session.failed} failed.`; } else { pendingProgressBar.classList.add('bg-red-500'); if(pendingProgressText) pendingProgressText.textContent='❌ All retries failed (still offline?).'; } if(pendingProgressPercent) pendingProgressPercent.textContent='100%'; pendingProgressBar.style.width='100%'; } setTimeout(()=> { if(pendingProgress) hide(pendingProgress); if(pendingProgressBar) pendingProgressBar.style.width = '0%'; }, 4000); logSyncSession({uploaded: session.uploaded, retried: session.retried, failed: session.failed, mode: 'Online Recovery'}); showSummary(session.failed > 0); updatePendingUI(); console.log("retryAllPendingUploads finished."); }

    // ---------- Sync summary banners ----------
    function showSummary(hadFailures=false){ /* ... same as before ... */ hide(syncProgress); if (!syncSummary || !syncSummaryText) return; const total=session.total || 0; let text; if (total === 0 && !hadFailures) { text = '✅ All items are synced.'; syncSummary.classList.remove('bg-yellow-700', 'text-yellow-100'); syncSummary.classList.add('bg-green-800', 'text-green-100'); } else if (session.failed > 0 || hadFailures) { syncSummary.classList.remove('bg-green-800', 'text-green-100'); syncSummary.classList.add('bg-yellow-700', 'text-yellow-100'); text = `⚠️ Sync Complete with errors — ${session.failed} item(s) failed and are cached offline.`; } else { syncSummary.classList.remove('bg-yellow-700', 'text-yellow-100'); syncSummary.classList.add('bg-green-800', 'text-green-100'); text = `✅ Sync Complete — ${session.uploaded + session.retried} item(s) uploaded successfully.`; } syncSummaryText.textContent = text; show(syncSummary); setTimeout(()=> hide(syncSummary), 10000); }

    // ---------- Sync history modal ----------
    function logSyncSession({uploaded=0,retried=0,failed=0,mode='Online'}){ /* ... same as before ... */ if (uploaded === 0 && retried === 0 && failed === 0) { console.log('Skipping logging empty sync session.'); return; } const history=offlineGet('syncHistory',[]); const entry={ time:new Date().toISOString(), uploaded, retried, failed, mode }; history.unshift(entry); if(history.length>10) history.splice(10); offlineSet('syncHistory', history); }
    function showSyncHistory(){ /* ... same as before ... */ if (!historyList || !historyModal) return; const history=offlineGet('syncHistory',[]); historyList.innerHTML=''; if(history.length===0){ historyList.innerHTML='<p class="text-gray-500 text-center">No sync history yet.</p>'; } else { history.forEach(entry=>{ const d=new Date(entry.time); const formatted=d.toLocaleString(undefined,{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'}); let color = 'text-green-400'; let statusText = `Uploaded: ${entry.uploaded || 0}`; if (entry.retried > 0) { statusText += ` • Retried: ${entry.retried}`; } if(entry.failed > 0) { color = 'text-red-400'; statusText += ` • Failed: ${entry.failed}`; } else if (entry.retried > 0 && entry.uploaded === 0) { color = 'text-yellow-400'; } const el = document.createElement('div'); el.className = 'flex justify-between items-start p-3 border-b border-gray-600 last:border-b-0'; el.innerHTML = ` <div> <p class="text-sm ${color} font-medium">${statusText}</p> <p class="text-xs text-gray-400">Mode: ${entry.mode || 'Unknown'}</p> </div> <span class="text-xs text-gray-500 flex-shrink-0 ml-2">${formatted}</span> `; historyList.appendChild(el); }); } show(historyModal); }

    // ---------- Event Handler Functions ----------
    // Includes handlers defined previously: handleTagFormSubmit, handleSignInLink, handleSignOut, handleOnline, handleOffline, handleSetupSave, handleSetupOffline, handleSaveClasses, handleClassPeriodChange, handleRetryAll, handleCopyLog, handleExportLog, handleToggleSyncLog, handleViewLogFromSummary, handleSyncCancel
    async function handleTagFormSubmit(e) { /* ... defined above ... */ }
    async function handleSignInLink() { /* ... defined above ... */ }
    function handleSignOut() { /* ... defined above ... */ }
    function handleOnline() { /* ... defined above ... */ }
    function handleOffline() { /* ... defined above ... */ }
    function handleSetupSave() { /* ... defined above ... */ }
    async function handleSetupOffline() {
  console.log("Setting up offline mode...");

  // 1. Set the global app mode variable
  appMode = 'offline'; 

  // 2. Save this choice to local storage so the app remembers
  try {
    // Using 'default-app-id' from your app's logs
    localStorage.setItem('seminar-app-id', 'default-app-id');
    localStorage.setItem('seminar-app-config', JSON.stringify({ mode: 'offline' }));
  } catch (e) {
    console.error("Failed to save offline settings to localStorage", e);
  }

  // 3. Hide the setup screen
  if (setupScreen) {
    hide(setupScreen);
  } else {
    console.error("Could not find setupScreen to hide!");
  }

  // 4. Show the main app screen
  // (This assumes the variable for your main app is 'mainAppScreen')
  if (mainAppScreen) { 
    show(mainAppScreen);
  } else {
    console.error("Could not find mainAppScreen to show!");
  }
}

   async function handleSaveClasses(e) { 
      e.preventDefault(); // Prevent potential form submission
      console.log('Saving class titles...');
      if (!classManagementForm) {
        console.error("Class management form not found!");
        toast('Error: Could not find class form elements.', 'error');
        return;
      }
      function handleClassPeriodChange(e) {
      const selectedPeriod = e.target.value;
      console.log('Class period changed to:', selectedPeriod);
      
      if (!studentSelect) {
        console.error("Student select dropdown not found");
        return;
      }

      // Clear the student dropdown first
      studentSelect.innerHTML = '<option value="">Select a student...</option>';
      studentSelect.disabled = true;

      if (!selectedPeriod) {
        studentSelect.innerHTML = '<option value="">Select a class period first...</option>';
        return; // No period selected
      }

      // Find the student list for the selected period
      const students = classData[selectedPeriod]?.students || [];

      if (students.length === 0) {
        studentSelect.innerHTML = '<option value="">No students in this class</option>';
        // Keep it disabled
      } else {
        // Populate the student dropdown
        students.forEach(studentName => {
          const option = document.createElement('option');
          option.value = studentName;
          option.textContent = studentName;
          studentSelect.appendChild(option);
        });
        studentSelect.disabled = false; // Enable the dropdown
      }
    }
      const updatedClassData = {};
      const inputs = classManagementForm.querySelectorAll('input[data-period]');
      
      inputs.forEach(input => {
        const period = input.dataset.period;
        if (period) {
          // Ensure the object exists before assigning the title
          if (!updatedClassData[period]) {
            // If it doesn't exist, try to copy existing students or default to empty
            updatedClassData[period] = { 
              title: input.value.trim(), 
              students: classData[period]?.students || [] // Keep existing students
            };
          } else {
             updatedClassData[period].title = input.value.trim();
          }
        }
      });

      // Update the global state
      classData = updatedClassData;
      
      // Save to localStorage (for offline mode)
      const cacheKey = `classData_${currentUserId || 'offline'}`;
      try {
        offlineSet(cacheKey, classData); 
        console.log('Class data saved to localStorage:', classData);
        toast('Class titles saved locally.', 'success');
        
        // Refresh the dropdowns immediately
        populateClassPeriodsDropdown(); 
        
      } catch (err) {
        console.error("Failed to save class data to localStorage:", err);
        toast('Error saving class titles locally.', 'error');
      }
    }

    // ---------- Event Listeners Setup (MOVED TO END) ----------
    function setupEventListeners() {
        console.log("Setting up event listeners...");
        // Ensure DOM refs are initialized before attaching listeners
        if (!startBtn) {
            console.warn("DOM refs not ready in setupEventListeners, initializing again.");
            initializeDomRefs(); // Re-initialize refs just in case
        }

        // Attach listeners with null checks
        if (startBtn) startBtn.addEventListener('click', startRecording); else console.error("Start button not found");
        if (pauseBtn) pauseBtn.addEventListener('click', pauseOrResume); else console.error("Pause button not found");
        if (stopBtn) stopBtn.addEventListener('click', stopRecording); else console.error("Stop button not found");
        if (toggleCameraBtn) {
             toggleCameraBtn.addEventListener('click', () => {
                 if (mediaRecorder && mediaRecorder.state === 'recording') {
                    toast('Cannot switch camera while recording.', 'warn');
                    return;
                }
                currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
                const newLabel = (currentFacingMode === 'user') ? 'Front' : 'Back';
                toast(`Switched to ${newLabel} Camera`);
                console.log('Camera set to:', currentFacingMode);
                // Simple restart for camera switch when not recording
                if (mediaStream) { // If preview is active
                    console.log("Restarting preview for camera switch...");
                    // Stop existing stream first
                    mediaStream.getTracks().forEach(t => t.stop());
                    mediaStream = null;
                    if (preview) preview.srcObject = null;
                    // Attempt to start with new constraints immediately
                    startRecording().catch(e => console.error("Error restarting preview after camera switch:", e));
                }
            });
        } else console.error("Toggle camera button not found");

        const tagForm = document.getElementById('tag-form');
        if (tagForm) tagForm.addEventListener('submit', handleTagFormSubmit); else console.error("Tag form not found");
        if (signInLinkBtn) signInLinkBtn.addEventListener('click', handleSignInLink); else console.error("Sign-in link button not found");
        if (signOutBtn) signOutBtn.addEventListener('click', handleSignOut); else console.error("Sign out button not found");
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        if (setupSave) setupSave.addEventListener('click', handleSetupSave); else console.error("Setup save button not found");
        if (setupOffline) setupOffline.addEventListener('click', handleSetupOffline); else console.error("Setup offline button not found");
        if (saveClassesBtn) saveClassesBtn.addEventListener('click', handleSaveClasses); else console.error("Save classes button not found");
        if (classPeriodSelect) classPeriodSelect.addEventListener('change', handleClassPeriodChange); else console.error("Class period select not found");
        if (retryAllBtn) retryAllBtn.addEventListener('click', handleRetryAll); else console.error("Retry all button not found");
        if (lastSyncEl) lastSyncEl.addEventListener('click', showSyncHistory); else console.error("Last sync element not found");
        if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', () => { if(historyModal) hide(historyModal); }); else console.error("Close history button not found");
        if (copyLogBtn) copyLogBtn.addEventListener('click', handleCopyLog); else console.error("Copy log button not found");
        if (exportLogBtn) exportLogBtn.addEventListener('click', handleExportLog); else console.error("Export log button not found");
        if (syncToggleLog) syncToggleLog.addEventListener('click', handleToggleSyncLog); else console.error("Sync toggle log button not found");
        if (viewLogBtn) viewLogBtn.addEventListener('click', handleViewLogFromSummary); else console.error("View log button (summary) not found");
        if (syncCancel) syncCancel.addEventListener('click', handleSyncCancel); else console.error("Sync cancel button not found");

        console.log("Event listeners setup complete.");
    }

    // ---------- Init (MOVED TO END & Corrected Order) ----------
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM fully loaded and parsed");
        initializeDomRefs(); // Initialize DOM refs *after* DOM is ready
        setupEventListeners(); //
        console.log('Booting app...');
        boot().then(() => { // Assuming boot can potentially have async ops before UI interaction
             console.log("Boot finished successfully, setting up listeners.");
            
             console.log("App ready."); // Log app readiness
        }).catch(bootError => {
             console.error("Critical error during boot:", bootError);
             if(errorMessageEl) errorMessageEl.textContent = `Critical boot error: ${bootError.message}\n${bootError.stack}`;
             if(errorDisplay) show(errorDisplay);
             hide(loadingScreen);
             // Attempt to show setup screen even on boot error if possible
             if (setupScreen) showScreen('setup-screen');
        });
    });

  </script>
</body>
</html>


